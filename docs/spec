First working prototype
  ðŸ—¸ All changes described below, done on the interface should be reflected on the content JSON.
  ðŸ—¸ Be able to re-order instances via drag and drop.
  ðŸ—¸ On mouse hover, only the selected instance should be highlighted and not itâ€™s parents too. (I have already solved this if you need to know how to do it in less than 5 minutes - see email I sent you)
  ðŸ—¸ Be able to add new modules to the content. (Idea: left pane)
  ðŸ—¸ Modules should be searchable/filterable by name and should show a preview
  ðŸ—¸ Be able to delete instance from the content via the garbage icon that appears on the toolbar.
  ðŸ—¸ Be able to duplicate instance from the content via the clone icon that appears on the toolbar.
  ðŸ—¸ Be able to edit properties of instance from the content, via the pencil icon that appears on the toolbar. On the right pane all editable properties should be shown, different controls for different property types. Currently supported: text, color, property.
  ðŸ—¸ Be able to preview final rendered  version
  ðŸ—¸ Be able to see modified content  json

Phase 2

Let me get a bit a ahead and specify the requirements of Phase 2A, which hopefully you can finish asap.

We need to re-organize the modules folder.
Current stucture is /modules/* and inside this folder are all modules defintions

New structure will be /modules/module-group-name/*
All module definitins will be on  /modules/module-group-name/*

Example with 2 module groups:
- /modules/email-html/*
- /modules/email-text/*

All files inside /modules/email-html/ will exist inside /modules/email-text/.
The difference is that the definitions will be different. In other words, the same modules that are in one folder will be in another folder, sames filenames, but differnet content.

Example:  /modules/email-html/block-list-item.js will contain 
output:"<li style="Margin: 0 0 10px 0;">%text%</li>" (for html rendering)

...while   /modules/email-text/block-list-item.js will contain
 output:"    * %text%" (for plain text rendering)

In this way the same content JSON can be used to render an HTML email or a TEXT-ONLY email by simply switching the module definitions.

Add to our app an additional input on the GUI interface which will be a select with the available module groups, by listing the folders available on /modules/.. This is the folder that will be used to load the modules, thus changing the render.

It would be ideal if you can replace this:

    <script src="modules/document-html-email.js"></script>
    <script src="modules/1-column-hero-image.js"></script>
    <script src="modules/1-column.js"></script>
    <script src="modules/1-column-spacer.js"></script>
    <script src="modules/2-column-image-image.js"></script>
:...

..by a generic command which will load all modules found on the modules/module-group/ folder. So we don't have to manually list one by one manually and we can easily add or remove new modules. You may use php to do this.

Add a Save button to our GUI. This save button will send the final JSON data via POST using ajax to save.php, using jquery post. With this done, I can later complete the php code and connect it to my system.


There is no way to edit GlobalProperties right now. Add a world icon button on the toolbar that when clicked displays on the right pane the global properties, so user can edit them. Look at content.js, the following properties should be editable:

var globalProperties = {
    "color1": "#eeeeee",
    "color2": "green",
    "backgroundColorBody": "white",
    "backgroundColorFooter": "blue",
    "backgroundColor": "#fff",
    "hiddenPreheader": "test",
};


Inside content.js we have var globalProperties, as mentioned above. I suggest refactoring this and putting global properties inside the contentJSON, so it is all inside one object, and so changes to Global properties don't get lost when exporting new  contentJSON.
Ex.: 

var content= {
   global: {...global properties ..},
   data: {... blocks...}
}

We need a very simple Node Js interface. Create a file called NodeJsRender.js which should take as input 1) Content JSON, 2) folder name (to be used to load the modules and that 3) returns the rendered output.

NodeRender.js should load the required dependencies (the module definitions) according to the module group choosen (the folder name)


Create a paired php file, NodeJsRender.php which shall take the same input and connect with NodeJS in this fashion:
exec("node NodeJsRender.js %parameters%", $result);

Please code this NodeJsRender.php as a sample to prove that the connection with NodeJsRender:js is working and that PHP can in fact get the result of the render.

You may have the NodeRender.js output the result via console.log() and in this way exec will read it. The result of the render will be used by a PHP application and there must be no delay nor errors, so I believe this is the most straightforward option, but I am open to suggestions. I believe having a full NodeJS server working is not a good option, and I believe this exec() option is easier and less prone to errors. Let me know what you think.


Please track time of Phase 2A separately so you bill me this new tracked time once you finish with 2A.